open Meta;
open Ast;
open AstHelpers;

open Ppxlib;
open Ast_helper;

let ext =
  Extension.declare(
    "form",
    Extension.Context.module_expr,
    Ast_pattern.__,
    (~loc, ~path as _, expr) => {
    switch (expr) {
    | PStr(structure) =>
      switch (structure |> Metadata.make) {
      | Ok({
          scheme,
          async,
          output_type,
          message_type,
          submission_error_type,
          validators_record,
          debounce_interval,
        }) =>
        // Once we gathered all required metadata and ensured that requirements are met
        // We need to iterate over user provided config and do the following:
        // 1. Open Formality module at the top of the generated module
        // 2. Inject types and values that either
        //    optional and weren't provided or just generated by ppx
        // 3. Update validators record (see Form_ValidatorsRecord for details)
        // 4. Append neccessary functions including useForm hook
        //
        // The strategy would be to find structure_item which contains
        // validators record and prepend types and values right before it.
        // Then prepend `open Formality` at the top & append functions
        // to the result list so those are at the bottom of the module.
        let opens = [Form_OpenFormality.ast(~loc)];

        let types = {
          let types =
            ref([
              Form_FieldsStatusesType.ast(~loc, scheme),
              Form_StateType.ast(~loc),
              Form_ActionType.ast(~loc, scheme),
              Form_ValidatorsType.ast(~loc, scheme),
              Form_InterfaceType.ast(~loc, ~async, scheme),
            ]);
          switch (submission_error_type) {
          | None => types := [SubmissionErrorType.default(~loc), ...types^]
          | Some () => ()
          };
          switch (message_type) {
          | None => types := [MessageType.default(~loc), ...types^]
          | Some () => ()
          };
          switch (output_type) {
          | NotProvided => types := [OutputType.default(~loc), ...types^]
          | AliasOfInput
          | Record(_) => ()
          };
          types^;
        };

        let values = {
          let values = ref([]);
          switch (debounce_interval) {
          | None when async =>
            values := [DebounceInterval.default(~loc), ...values^]
          | None
          | Some () => ()
          };
          values^;
        };

        let funcs = [
          Form_InitialFieldsStatusesFn.ast(~loc, scheme),
          Form_InitialStateFn.ast(~loc),
          async
            ? Form_ValidateFormFn_Async.ast(~loc, scheme)
            : Form_ValidateFormFn_Sync.ast(~loc, scheme),
          Form_UseFormFn.ast(~loc, ~async, scheme),
        ];

        let structure: structure =
          List.fold_right(
            (structure_item: structure_item, acc) =>
              switch (structure_item) {
              | {pstr_desc: Pstr_value(rec_flag, value_bindings), pstr_loc} =>
                let (value_bindings, search_result) =
                  List.fold_right(
                    (value, (acc, res: [ | `Found | `NotFound])) =>
                      switch (value) {
                      | {
                          pvb_pat: {ppat_desc: Ppat_var({txt: "validators"})},
                        } as value => (
                          [
                            value
                            |> Form_ValidatorsRecord.ast(
                                 scheme,
                                 validators_record,
                               ),
                            ...acc,
                          ],
                          `Found,
                        )
                      | _ as value => ([value, ...acc], res)
                      },
                    value_bindings,
                    ([], `NotFound),
                  );
                let structure_item = {
                  pstr_desc: Pstr_value(rec_flag, value_bindings),
                  pstr_loc,
                };
                switch (search_result) {
                | `NotFound => [structure_item, ...acc]
                | `Found =>
                  List.append(
                    List.append(types, values),
                    [structure_item, ...acc],
                  )
                };
              | _ => [structure_item, ...acc]
              },
            structure,
            funcs,
          );

        Mod.mk(Pmod_structure(List.append(opens, structure)));

      | Error(InputTypeParseError(NotFound)) =>
        Location.raise_errorf(~loc, "`input` type not found")
      | Error(InputTypeParseError(NotRecord(loc))) =>
        Location.raise_errorf(~loc, "`input` must be of record type")
      | Error(InputTypeParseError(InvalidAsyncField(InvalidPayload(loc)))) =>
        Location.raise_errorf(
          ~loc,
          "`@field.async` attribute accepts only optional record `{mode: OnChange | OnBlur}`",
        )
      | Error(InputTypeParseError(InvalidAsyncField(InvalidAsyncMode(loc)))) =>
        Location.raise_errorf(
          ~loc,
          "Invalid async mode. Use either `OnChange` or `OnBlur`.",
        )
      | Error(InputTypeParseError(InvalidFieldDeps(DepsParseError(loc)))) =>
        Location.raise_errorf(
          ~loc,
          "`@field.deps` attribute must contain field or tuple of fields",
        )
      | Error(
          InputTypeParseError(
            InvalidFieldDeps(DepNotFound(`Field(dep, loc))),
          ),
        ) =>
        Location.raise_errorf(~loc, "Field `%s` doesn't exist in input", dep)
      | Error(
          InputTypeParseError(
            InvalidFieldDeps(DepOfItself(`Field(dep, loc))),
          ),
        ) =>
        Location.raise_errorf(~loc, "Field `%s` depends on itself", dep)
      | Error(
          InputTypeParseError(
            InvalidFieldDeps(DepDuplicate(`Field(dep, loc))),
          ),
        ) =>
        Location.raise_errorf(
          ~loc,
          "Field `%s` is already declared as a dependency for this field",
          dep,
        )
      | Error(OutputTypeParseError(NotRecord(loc))) =>
        Location.raise_errorf(
          ~loc,
          "`output` must be of record type or an alias of `input`",
        )
      | Error(OutputTypeParseError(BadTypeAlias({alias, loc}))) =>
        Location.raise_errorf(
          ~loc,
          "`output` can only be an alias of `input` type or a record",
        )
      | Error(ValidatorsRecordParseError(NotFound)) =>
        Location.raise_errorf(~loc, "`validators` record not found")
      | Error(
          ValidatorsRecordParseError(NotRecord(loc) | RecordParseError(loc)),
        ) =>
        Location.raise_errorf(
          ~loc,
          "Failed to parse `validators` record. Please, file an issue with your use-case.",
        )
      | Error(ValidatorsRecordParseError(BadTypeAnnotation(loc))) =>
        Location.raise_errorf(
          ~loc,
          "`validators` binding must be of `validators` type. You can safely remove type annotation and it will be annotated for you under the hood.",
        )
      | Error(
          ValidatorsRecordParseError(
            ValidatorError(
              `BadRequiredValidator(field, `Some(loc) | `None(loc), reason),
            ),
          ),
        ) =>
        switch (reason) {
        | `DifferentIO(input_type, output_type) =>
          Location.raise_errorf(
            ~loc,
            "Validator for `%s` field is required because its input and output types are different. So validator function is required to produce value of output type from an input value.",
            switch (field) {
            | Field(field) => field
            },
          )
        | `IncludedInDeps(in_deps_of_field) =>
          Location.raise_errorf(
            ~loc,
            "Validator for `%s` field is required because this field is included in deps of `%s` field",
            switch (field) {
            | Field(field) => field
            },
            switch (in_deps_of_field) {
            | Field(field) => field
            },
          )
        }
      | Error(IOMismatch(OutputFieldsNotInInput({fields}))) =>
        switch (fields) {
        | [] =>
          failwith(
            "Empty list of non-matched fields in IOMatchError(OutputFieldsNotInInput)",
          )
        | [(field, loc)]
        | [(field, loc), ..._] =>
          Location.raise_errorf(
            ~loc,
            "`output` field `%s` doesn't exist in `input` type",
            switch (field) {
            | Field(field) => field
            },
          )
        }
      | Error(IOMismatch(InputFieldsNotInOutput({fields, loc})))
      | Error(
          IOMismatch(
            Both({
              input_fields_not_in_output: fields,
              output_fields_not_in_input: _,
              loc,
            }),
          ),
        ) =>
        switch (fields) {
        | [] =>
          failwith("Empty list of non-matched fields in IOMatchError(Both)")
        | [field] =>
          Location.raise_errorf(
            ~loc,
            "`input` field `%s` doesn't exist in `output` type",
            switch (field) {
            | Field(field) => field
            },
          )
        | fields =>
          Location.raise_errorf(
            ~loc,
            "Some `input` fields don't exist in `output` type: %s",
            fields
            |> List.map((field: Field.t) =>
                 switch (field) {
                 | Field(field) => field
                 }
               )
            |> String.concat(", "),
          )
        }
      }
    | _ => Location.raise_errorf(~loc, "Must be a structure")
    }
  });
